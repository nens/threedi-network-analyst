# -*- coding: utf-8 -*-
"""
/***************************************************************************
 ThreeDiNetworkAnalystDockWidget
                                 A QGIS plugin
 Use network analysis for 3Di results
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2020-09-07
        git sha              : $Format:%H$
        copyright            : (C) 2020 by Nelen & Schuurmans
        email                : leendert.vanwolfswinkel@nelen-schuurmans.nl
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

# TODO Catchment id toevoegen aan impervious surface
# TODO ResultSetAdmin implementeren
# TODO pan to result set when browsing
# TODO Analyzed target nodes behouden bij afsluiten plugin
# TODO analyzed target nodes leegmaken bij clear ouputs

# TODO: If source is polygon layer, transfer polygon id to result layers
# TODO upstream catchment iets breder interpreteren (area of influence) door downstream nodes mee te nemen (successors)
# TODO maptool eigen cursor symbooltje geven
# TODO 1D nodes ook als target nodes laten selecteren
# TODO mogelijkheid om van een pand op te vragen wat het downstream effect is
# TODO: Make smoothing parameters depedent on cell size

# TODO: Allow save and loading of result sets to a single geopackage incl. styling

import pathlib
from qgis.PyQt import QtGui, QtWidgets, uic
from qgis.PyQt.QtCore import pyqtSignal, Qt
from qgis.core import (
    QgsProject,
    QgsFeatureRequest,
    QgsExpression,
    QgsMapLayer,
    QgsVectorLayer,
    QgsGeometry,
    QgsProcessingFeedback,
    QgsMapLayerProxyModel
)
from qgis import utils
from qgis.gui import QgsMapToolIdentify
from qgis import processing

from threedigrid.admin.gridresultadmin import GridH5ResultAdmin

from .threedigrid_networkx import *
from .threedi_network_analysis import *
from .ogr2qgis import *
from .smoothing import *

# This loads your .ui file so that PyQt can populate your plugin with the elements from Qt Designer
FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'threedi_network_analysis_dockwidget_base.ui'))

STYLE_DIR = os.path.join(os.path.dirname(__file__), 'style')
MEMORY_DRIVER = ogr.GetDriverByName('MEMORY')
DEFAULT_THRESHOLD = 1


class LayerExistsError(Exception):
    """Raised when attempting to create a target_node_layer that already exists"""
    pass


def add_locked_layer(layer, add_to_layer_tree=True):
    """
    Add a layer to the layer tree that cannot be removed by the user

    :param layer: layer to add
    """
    project = QgsProject.instance()
    project.addMapLayer(layer, addToLegend=False)
    if add_to_layer_tree:
        project.layerTreeRoot().insertLayer(0, layer)
    layer.setFlags(QgsMapLayer.Searchable | QgsMapLayer.Identifiable)


def bbox_of_features(features: List):
    first_pass = True
    for feat in features:
        if first_pass:
            bbox = feat.geometry().boundingBox()
            first_pass = False
        else:
            bbox.combineExtentWith(feat.geometry().boundingBox())
    return bbox


class ResultSetAdmin:
    """Keeps administration of all results that belong to a result set"""
    def __init__(self, parent, id: int):
        self.parent = parent
        self.id = id
        self._bbox = None

    @property
    def bbox(self):
        return self._bbox

    def update_bbox(self):
        # cells
        request = QgsFeatureRequest().setFilterExpression(f'catchment_id in ({self.id})')
        features = self.parent.result_cell_layer.getFeatures(request)
        cells_bbox = bbox_of_features(features=features)
        bbox = cells_bbox

        # flowlines
        request = QgsFeatureRequest().setFilterExpression(f'catchment_id in ({self.id})')
        features = self.parent.result_flowline_layer.getFeatures(request)
        flowlines_bbox = bbox_of_features(features=features)
        bbox.combineExtentWith(flowlines_bbox)

        # impervious surfaces
        if self.parent.result_impervious_surface_layer is not None:
            request = QgsFeatureRequest().setFilterExpression(f'catchment_id in ({self.id})')
            features = self.parent.result_impervious_surface_layer.getFeatures(request)
            impervious_surface_bbox = bbox_of_features(features=features)
            bbox.combineExtentWith(impervious_surface_bbox)

        self._bbox = bbox
        # self.canvas.setExtent(zoomRectangle)


class Graph3DiQgsConnector:
    """Connect a Graph3Di and its inputs and outputs to a QGIS Project"""
    # TODO: class alles laten erven van Graph3Di en evt. nieuw object met alle QGIS-dingen
    result_cell_attr_types = {
        'id': ogr.OFTInteger,
        'node_type': ogr.OFTInteger,
        'node_type_description': ogr.OFTString,
        'location': ogr.OFTString,
        'catchment_id': ogr.OFTInteger,
        'from_polygon': ogr.OFTInteger
    }

    result_flowline_attr_types = {
        'id': ogr.OFTInteger,
        'content_type': ogr.OFTString,
        'kcu': ogr.OFTInteger,
        'kcu_description': ogr.OFTString,
        'location': ogr.OFTString,
        'catchment_id': ogr.OFTInteger,
        'from_polygon': ogr.OFTInteger
    }

    def __init__(self, canvas, epsg=28992):
        """Constructor."""
        self._filter = None
        self.canvas = canvas
        self.epsg = epsg
        self.graph_3di = Graph3Di(subset=None)
        self._sqlite = None

        # TODO deze lagen netjes in een groep plaatsen
        self.create_or_replace_target_node_layer()
        self.create_result_cell_layer()
        self.create_result_flowline_layer()
        self.create_catchment_layer()
        self.impervious_surface_layer = None

        self.result_sets = []
        self.dissolved_result_sets = []
        self.smooth_result_catchments = []
        QgsProject.instance().cleared.connect(self.clean_up_locked_layers)

    def __del__(self):
        self.clean_up_locked_layers()
        QgsProject.instance().cleared.disconnect(self.clean_up_locked_layers)

    @property
    def gr(self):
        return self.graph_3di.gr

    @gr.setter
    def gr(self, value):
        self.graph_3di.gr = value
        self.create_or_replace_target_node_layer()

    @property
    def sqlite(self):
        return self._sqlite

    @sqlite.setter
    def sqlite(self, sqlite):
        sqlite_pathlib_path = pathlib.Path(sqlite)
        if not isinstance(sqlite_pathlib_path, pathlib.PurePath):
            raise TypeError
        value_changed = sqlite != self._sqlite
        self._sqlite = sqlite_pathlib_path
        if value_changed:
            if self.impervious_surface_layer is None and self._sqlite is not None:
                self.create_impervious_surface_layer()

    @property
    def threshold(self):
        return self.graph_3di.threshold

    @threshold.setter
    def threshold(self, value):
        self.graph_3di.threshold = value

    @property
    def start_time(self):
        return self.graph_3di.start_time

    @start_time.setter
    def start_time(self, value):
        self.graph_3di.start_time = value

    @property
    def end_time(self):
        return self.graph_3di.end_time

    @end_time.setter
    def end_time(self, value):
        self.graph_3di.end_time = value

    @property
    def filter(self):
        return self._filter

    @filter.setter
    def filter(self, ids: List):
        if isinstance(ids, list):
            for id_i in ids:
                if not isinstance(id_i, int):
                    raise TypeError('Filter must be set to None or list of int')
            self._filter = ids.copy()
        elif ids is None:
            self._filter = None
        else:
            raise TypeError('Filter must be set to None or list of int')
        filtered_ids = set(self.result_sets) & set(self._filter if self._filter is not None else self.result_sets)
        filtered_ids_str = ','.join(map(str, filtered_ids))
        if self._filter is None:
            subset_string = ''
            target_node_layer_analyzed_nodes_rule_str = "result_sets != ''"
        else:
            subset_string = 'catchment_id IN ({})'.format(filtered_ids_str)
            target_node_layer_analyzed_nodes_rule_str = f'array_intersect( string_to_array("result_sets"),  array({filtered_ids_str}))'

        flowline_subset_string = ' AND '.join(filter(None, [subset_string, 'kcu != 100'])) # filter to leave subset_string out if empty
        self.result_catchment_layer.setSubsetString(subset_string)
        print(f'filter(): result catchment layer filter set to {subset_string}')
        self.result_cell_layer.setSubsetString(subset_string)
        self.result_flowline_layer.setSubsetString(flowline_subset_string)
        self.target_node_layer.renderer().rootRule().children()[0].setFilterExpression(target_node_layer_analyzed_nodes_rule_str)

    def new_result_set_id(self):
        if len(self.result_sets) == 0:
            self.result_sets.append(1)  # 1-based index because this is common in GIS id fields
        else:
            self.result_sets.append(max(self.result_sets) + 1)
        return max(self.result_sets)

    def clean_up_locked_layers(self):
        """For all locked layers, remove locks or layers themselves"""
        try:
            if self.target_node_layer is not None:
                QgsProject.instance().removeMapLayer(self.target_node_layer)
                del self.target_node_layer
        except AttributeError:
            pass

        try:
            if self.result_cell_layer is not None:
                if self.result_cell_layer.featureCount() == 0:
                    QgsProject.instance().removeMapLayer(self.result_cell_layer)
                    del self.result_cell_layer
                else:
                    self.result_cell_layer.setFlags(
                        QgsMapLayer.Searchable | QgsMapLayer.Identifiable | QgsMapLayer.Removable)
        except AttributeError:
            pass

        try:
            if self.result_flowline_layer is not None:
                if self.result_flowline_layer.featureCount() == 0:
                    QgsProject.instance().removeMapLayer(self.result_flowline_layer)
                    del self.result_flowline_layer
                else:
                    self.result_flowline_layer.setFlags(
                        QgsMapLayer.Searchable | QgsMapLayer.Identifiable | QgsMapLayer.Removable)
        except AttributeError:
            pass

        try:
            if self.result_catchment_layer is not None:
                if self.result_catchment_layer.featureCount() == 0:
                    QgsProject.instance().removeMapLayer(self.result_catchment_layer)
                    del self.result_catchment_layer
                else:
                    self.result_catchment_layer.setFlags(
                        QgsMapLayer.Searchable | QgsMapLayer.Identifiable | QgsMapLayer.Removable)
        except AttributeError:
            pass

        try:
            if self.impervious_surface_layer is not None:
                if self.impervious_surface_layer.featureCount() == 0:
                    QgsProject.instance().removeMapLayer(self.impervious_surface_layer)
                    del self.impervious_surface_layer
                else:
                    self.impervious_surface_layer.setFlags(
                        QgsMapLayer.Searchable | QgsMapLayer.Identifiable | QgsMapLayer.Removable)
        except AttributeError:
            pass

        self.canvas.refresh()

    def create_or_replace_target_node_layer(self):
        self.remove_target_node_layer()
        if isinstance(self.gr, GridH5ResultAdmin):
            nodes = self.gr.nodes.subset("2D_ALL")
            nodes_ds = MEMORY_DRIVER.CreateDataSource('')
            attributes = {'result_sets': [''] * nodes.count}
            attr_data_types = {'result_sets': ogr.OFTString}
            threedigrid_to_ogr(threedigrid_src=nodes,
                               tgt_ds=nodes_ds,
                               attributes=attributes,
                               attr_data_types=attr_data_types)
            ogr_lyr = nodes_ds.GetLayerByName('node')
            self.target_node_layer = as_qgis_memory_layer(ogr_lyr, 'Target nodes')
            qml = os.path.join(STYLE_DIR, 'target_nodes.qml')
            self.target_node_layer.loadNamedStyle(qml)
            add_locked_layer(self.target_node_layer)
            # TODO Add to group, put group on top of target_node_layer tree

    def remove_target_node_layer(self):
        try:
            if self.target_node_layer is not None:
                project = QgsProject.instance()
                project.removeMapLayer(self.target_node_layer)
        except AttributeError:
            pass
        self.target_node_layer = None

    def create_result_cell_layer(self):
        try:
            if self.result_cell_layer is not None:
                raise LayerExistsError('Attempt to create existing result cell layer')
        except AttributeError:
            pass
        ogr_driver = ogr.GetDriverByName('Memory')
        ogr_data_source = ogr_driver.CreateDataSource('')
        srs = osr.SpatialReference()
        srs.ImportFromEPSG(self.epsg)
        ogr_lyr = ogr_data_source.CreateLayer('', srs, geom_type=ogr.wkbPolygon)
        for fieldname, fieldtype in self.result_cell_attr_types.items():
            field = ogr.FieldDefn(fieldname, fieldtype)
            ogr_lyr.CreateField(field)

        qgs_lyr_name = 'Result cells'
        self.result_cell_layer = as_qgis_memory_layer(ogr_lyr, qgs_lyr_name)
        qml = os.path.join(STYLE_DIR, 'result_cells.qml')
        self.result_cell_layer.loadNamedStyle(qml)
        add_locked_layer(self.result_cell_layer)

    def update_analyzed_target_cells(self, target_node_ids, result_set):
        ids_str = ','.join(map(str, target_node_ids))
        expression_str = f'id IN ({ids_str})'
        print(expression_str)
        request = QgsFeatureRequest()
        request.setFilterExpression(f'id IN ({ids_str})')
        idx = self.target_node_layer.fields().indexFromName('result_sets')
        self.target_node_layer.startEditing()
        for feat in self.target_node_layer.getFeatures(request):
            print(f"update target node {feat['id']} with fid {feat.id()}")
            old_result_sets = feat['result_sets']
            result_sets_list = old_result_sets.split(',')
            result_sets_list.append(result_set)
            new_result_sets = ','.join(map(str, result_sets_list))
            print(f'new result sets string = {new_result_sets}')
            self.target_node_layer.changeAttributeValue(feat.id(), idx, new_result_sets)
        self.target_node_layer.commitChanges()

    def find_cells(self, target_node_ids: List, upstream: bool, result_set: int):
        """Find cells upstream or downstream from the list of target nodes and append them to the result cell layer"""
        if upstream:
            cell_ids_full_set = self.graph_3di.upstream_nodes(target_node_ids)
        else:
            cell_ids_full_set = self.graph_3di.downstream_nodes(target_node_ids)
        # cell_ids = cell_ids_full_set - set(target_node_ids)
        self.append_result_cells(cell_ids=cell_ids_full_set, upstream=upstream, result_set=result_set)
        self.update_analyzed_target_cells(target_node_ids, result_set)

    def append_result_cells(self, cell_ids, upstream: bool, result_set: int):
        cells = self.gr.cells.filter(id__in=list(cell_ids))

        nw_ids = list(cells.id)

        nw_catchment_ids = [result_set] * cells.count

        if upstream:
            location = ['upstream'] * cells.count
        else:
            location = ['downstream'] * cells.count

        from_polygon = [0] * cells.count

        attributes = {
            'id': nw_ids,
            'location': location,
            'catchment_id': nw_catchment_ids,
            'from_polygon': from_polygon
        }

        ds = MEMORY_DRIVER.CreateDataSource('')
        threedigrid_to_ogr(threedigrid_src=cells,
                           tgt_ds=ds,
                           attributes=attributes,
                           attr_data_types=self.result_cell_attr_types
                           )
        layer = ds.GetLayerByName('cell')
        append_to_qgs_vector_layer(ogr_layer=layer, qgs_vector_layer=self.result_cell_layer)
        self.result_cell_layer.triggerRepaint()

    def clear_result_cell_layer(self):
        """Remove all features from layer that contains the upstream and/or downstream cells"""
        self.result_cell_layer.dataProvider().truncate()

    def remove_result_cell_layer(self):
        """Remove layer that contains the upstream and/or downstream cells"""
        if self.result_cell_layer is not None:
            QgsProject.instance().removeMapLayer(self.result_cell_layer)
            self.result_cell_layer = None

    def create_result_flowline_layer(self):
        try:
            if self.result_flowline_layer is not None:
                raise LayerExistsError('Attempt to create existing result flowline layer')
        except AttributeError:
            pass
        ogr_driver = ogr.GetDriverByName('Memory')
        ogr_data_source = ogr_driver.CreateDataSource('')
        srs = osr.SpatialReference()
        srs.ImportFromEPSG(self.epsg)
        ogr_lyr = ogr_data_source.CreateLayer('', srs, geom_type=ogr.wkbLineString)
        for fieldname, fieldtype in self.result_flowline_attr_types.items():
            field = ogr.FieldDefn(fieldname, fieldtype)
            ogr_lyr.CreateField(field)

        qgs_lyr_name = 'Result flowlines (1D)'
        self.result_flowline_layer = as_qgis_memory_layer(ogr_lyr, qgs_lyr_name)
        qml = os.path.join(STYLE_DIR, 'result_flowlines.qml')
        self.result_flowline_layer.loadNamedStyle(qml)
        add_locked_layer(self.result_flowline_layer)
        self.result_flowline_layer.setSubsetString('kcu != 100')

    def find_flowlines(self, target_node_ids: List, upstream: bool, result_set: int):
        """Find flowlines upstream or downstream from the list of target nodes \
        and append them to the result flowline layer"""
        # TODO make a function that takes a list of result nodes as input
        print('find_flowlines called')
        if upstream:
            flowlines_ids = self.graph_3di.upstream_flowlines(target_node_ids)
        else:
            flowlines_ids = self.graph_3di.downstream_flowlines(target_node_ids)
        self.append_result_flowlines(flowline_ids=flowlines_ids, upstream=upstream, result_set=result_set)

    def append_result_flowlines(self, flowline_ids, upstream: bool, result_set: int):
        flowlines = self.gr.lines.filter(id__in=list(flowline_ids))
        nw_ids = list(flowlines.id)
        nw_catchment_ids = [result_set] * flowlines.count
        if upstream:
            location = ['upstream'] * flowlines.count
        else:
            location = ['downstream'] * flowlines.count
        from_polygon = [0] * flowlines.count
        attributes = {
            'id': nw_ids,
            'location': location,
            'catchment_id': nw_catchment_ids,
            'from_polygon': from_polygon
        }

        ds = MEMORY_DRIVER.CreateDataSource('')
        threedigrid_to_ogr(threedigrid_src=flowlines,
                           tgt_ds=ds,
                           attributes=attributes,
                           attr_data_types=self.result_flowline_attr_types
                           )
        layer = ds.GetLayerByName('flowline')
        append_to_qgs_vector_layer(ogr_layer=layer, qgs_vector_layer=self.result_flowline_layer)
        self.result_flowline_layer.triggerRepaint()

    def clear_result_flowline_layer(self):
        """Remove all features from layer that contains the upstream and/or downstream flowlines"""
        self.result_flowline_layer.dataProvider().truncate()

    def remove_result_flowline_layer(self):
        """Remove layer that contains the upstream and/or downstream flowlines"""
        if self.result_cell_layer is not None:
            QgsProject.instance().removeMapLayer(self.result_cell_layer)
            self.result_cell_layer = None

    def create_catchment_layer(self):
        try:
            if self.result_catchment_layer is not None:
                raise LayerExistsError('Attempt to create existing result catchment layer')
        except AttributeError:
            pass
        ogr_driver = ogr.GetDriverByName('Memory')
        ogr_data_source = ogr_driver.CreateDataSource('')
        srs = osr.SpatialReference()
        srs.ImportFromEPSG(self.epsg)
        ogr_lyr = ogr_data_source.CreateLayer('', srs, geom_type=ogr.wkbPolygon)

        for fieldname, fieldtype in self.result_cell_attr_types.items():
            field = ogr.FieldDefn(fieldname, fieldtype)
            ogr_lyr.CreateField(field)

        qgs_lyr_name = 'Result catchments'
        self.result_catchment_layer = as_qgis_memory_layer(ogr_lyr, qgs_lyr_name)
        qml = os.path.join(STYLE_DIR,
                           'result_catchments.qml')
        self.result_catchment_layer.loadNamedStyle(qml)
        add_locked_layer(self.result_catchment_layer)

    def clear_catchment_layer(self):
        """Remove all features from layer that contains the upstream and/or downstream cells"""
        fids = [feat.id() for feat in self.result_catchment_layer.getFeatures()]
        self.result_catchment_layer.dataProvider().truncate()
        self.result_catchment_layer.featuresDeleted.emit(fids)

    def dissolve_cells(self):
        """Dissolve cells in self.result_cells_layer of all not yet dissolved result sets"""
        saved_subsetstring = self.result_cell_layer.subsetString()
        non_dissolved_ids = set(self.result_sets) - set(self.dissolved_result_sets)
        non_dissolved_ids_str = ','.join(map(str, non_dissolved_ids))
        subset_string = 'catchment_id IN ({})'.format(non_dissolved_ids_str)
        self.result_cell_layer.setSubsetString(subset_string)
        # saved_filter = self.filter
        # self.filter = list(set(self.result_sets) - set(self.dissolved_result_sets))

        feedback = QgsProcessingFeedback()
        dslv_params = {
            'INPUT': self.result_cell_layer,  # QgsVectorLayer
            'FIELD': ['location', 'catchment_id'],  # dissolve field (str)
            'OUTPUT': 'memory:'
        }

        multipolys = processing.run('qgis:dissolve', dslv_params, feedback=feedback)['OUTPUT']
        to_single_params = {
            'INPUT': multipolys,  # QgsVectorLayer
            'OUTPUT': 'memory:Result Catchments'
        }
        nw_result_catchments_layer = processing.run('qgis:multiparttosingleparts',
                                                    to_single_params,
                                                    feedback=feedback
                                                    )['OUTPUT']

        self.result_catchment_layer.startEditing()
        self.result_catchment_layer.dataProvider().addFeatures(nw_result_catchments_layer.getFeatures())
        self.result_catchment_layer.commitChanges()
        self.dissolved_result_sets = self.result_sets.copy()
        self.result_catchment_layer.triggerRepaint()
        self.result_cell_layer.setSubsetString(saved_subsetstring)
        self.result_catchment_layer.featureAdded.emit(self.result_catchment_layer.featureCount())
        # self.result_cell_layer.triggerRepaint()

    def smooth_catchment_layer(self):
        print(f'smooth_catchment_layer(): self.filter = {self.filter}')
        saved_subsetstring = self.result_catchment_layer.subsetString()
        self.result_catchment_layer.setSubsetString('')
        self.result_catchment_layer.startEditing()
        for feature in self.result_catchment_layer.getFeatures():
            if feature.id() not in self.smooth_result_catchments:
                geom = feature.geometry()
                ogr_geom = ogr.CreateGeometryFromWkb(geom.asWkb())
                ogr_geom_smooth = polygon_gaussian_smooth(ogr_geom, sigma=10, sample_dist=2)
                qgs_geom_smooth = QgsGeometry()
                qgs_geom_smooth.fromWkb(ogr_geom_smooth.ExportToWkb())
                self.result_catchment_layer.changeGeometry(feature.id(), qgs_geom_smooth)
            self.smooth_result_catchments.append(feature.id())
        self.result_catchment_layer.commitChanges()
        self.result_catchment_layer.setSubsetString(saved_subsetstring)

    def create_impervious_surface_layer(self):
        self.impervious_surface_source_layer = QgsVectorLayer(
            path=str(self.sqlite) + '|layername=v2_impervious_surface',
            baseName='v2_impervious_surface',
            providerLib='ogr'
        )

        fields = self.impervious_surface_source_layer.fields().toList()
        self.impervious_surface_layer = QgsVectorLayer('Polygon', 'Impervious surface', 'memory')
        success = self.impervious_surface_layer.dataProvider().addAttributes(fields)
        self.impervious_surface_layer.updateFields()
        qml = os.path.join(STYLE_DIR,
                           'result_impervious_surfaces.qml')
        self.impervious_surface_layer.loadNamedStyle(qml)
        add_locked_layer(self.impervious_surface_layer)

    def append_impervious_surfaces(self, ids: List = None, expression: str = None):
        """Copy features from the source v2_impervious_surface table to the result table
        impervious surfaces may be selected by ids or by expression. Expression overrules ids"""
        # TODO add result set
        if expression is None:
            ids_str = ','.join(map(str, ids))
            expression = f'id IN ({ids_str})'
        self.impervious_surface_source_layer.setSubsetString(expression)
        features = self.impervious_surface_source_layer.getFeatures()
        self.result_catchment_layer.startEditing()
        success = self.impervious_surface_layer.dataProvider().addFeatures(features)
        if not success:
            print('adding features to impervious surface layer failed')
        self.impervious_surface_layer.commitChanges()
        self.impervious_surface_layer.updateExtents()

    def clear_impervious_surface_layer(self):
        """Remove all features from layer"""
        self.impervious_surface_layer.dataProvider().truncate()

    def remove_impervious_surface_layer(self):
        """Remove layer that contains the upstream and/or downstream flowlines"""
        if self.impervious_surface_layer is not None:
            QgsProject.instance().removeMapLayer(self.impervious_surface_layer)
            self.impervious_surface_layer = None

    def find_impervious_surfaces(self, node_ids: List, result_set: int = None):
        """Find impervious surfaces connected to nodes \
        and append them to the impervious surface layer"""
        if self.impervious_surface_layer is not None and self.sqlite is not None:
            nodes = self.gr.nodes.filter(id__in=node_ids)
            connection_node_ids = set(nodes.content_pk) - {None, -9999}
            connection_node_ids_str = ','.join(map(str, connection_node_ids))
            expression = f"""   id in (
                                    SELECT impervious_surface_id 
                                    FROM v2_impervious_surface_map 
                                    WHERE connection_node_id IN ({connection_node_ids_str})
                                ) """
            print(expression)
            self.append_impervious_surfaces(expression=expression)


class CatchmentMapTool(QgsMapToolIdentify):
    def __init__(self,
                 gq: Graph3DiQgsConnector,
                 upstream=False,
                 downstream=False,
                 parent_button=None
                 ):
        super().__init__(gq.canvas)
        self.gq = gq
        self.upstream = upstream
        self.downstream = downstream
        self.parent_button = parent_button
        self.set_cursor()
        print('Curious, init?')

    @property
    def upstream(self):
        return self._upstream

    @upstream.setter
    def upstream(self, value):
        self._upstream = value

    @property
    def downstream(self):
        return self._downstream

    @downstream.setter
    def downstream(self, value):
        self._downstream = value

    def canvasReleaseEvent(self, event):
        x = event.pos().x()
        y = event.pos().y()

        identify_results = self.identify(x=int(x), y=int(y), layerList=[self.gq.target_node_layer])
        if len(identify_results) == 0:
            pass
            # TODO give user some gentle feedback that no node was clicked
        else:
            result_set = self.gq.new_result_set_id()
            target_node_id = identify_results[0].mFeature.id()
            if self.upstream:
                self.gq.find_cells(target_node_ids=[target_node_id], upstream=True, result_set=result_set)
                self.gq.find_flowlines(target_node_ids=[target_node_id], upstream=True, result_set=result_set)
                self.gq.find_impervious_surfaces(
                    node_ids=list(self.gq.graph_3di.upstream_nodes(target_node_ids=[target_node_id])))
            if self.downstream:
                self.gq.find_cells(target_node_ids=[target_node_id], upstream=False, result_set=result_set)
                self.gq.find_flowlines(target_node_ids=[target_node_id], upstream=False, result_set=result_set)
            self.gq.dissolve_cells()
            self.gq.smooth_catchment_layer()

    def activate(self):
        pass

    def deactivate(self):
        if self.parent_button is not None:
            self.parent_button.setChecked(False)

    def isZoomTool(self):
        return False

    def isTransient(self):
        return False

    def isEditTool(self):
        return True

    def set_cursor(self):
        cursor = QtGui.QCursor()
        cursor.setShape(Qt.CrossCursor)
        self.canvas().setCursor(cursor)
        print("I really did try to change the cursor")
        # utils.iface.iface.mainWindow().centralWidget().setCursor(cursor)
        # QtGui.QApplication.instance().setOverrideCursor(cursor)


class ThreeDiNetworkAnalystDockWidget(QtWidgets.QDockWidget, FORM_CLASS):
    closingPlugin = pyqtSignal()

    # TODO: auto-Enable/disable buttons in Target Nodes and Outputs sections
    def __init__(self, iface, parent=None, epsg=28992):
        """Constructor."""
        super(ThreeDiNetworkAnalystDockWidget, self).__init__(parent)
        # Set up the user interface from Designer.
        # After setupUI you can access any designer object by doing
        # self.<objectname>, and you can use autoconnect slots - see
        # http://doc.qt.io/qt-5/designer-using-a-ui-file.html
        # #widgets-and-dialogs-with-auto-connect
        self.setupUi(self)

        self.iface = iface
        self.epsg = epsg
        self.gq = Graph3DiQgsConnector(canvas=self.iface.mapCanvas())
        self.gq.start_time = 0  # initial value of widget is 0, so valueChanged() signal will not be emitted when ...
        # ... a 3Di result is loaded for the first time
        self.gq.result_catchment_layer.featureAdded.connect(self.result_sets_count_changed)
        self.gq.result_catchment_layer.featuresDeleted.connect(self.result_sets_count_changed)

        self.mMapLayerComboBoxTargetPolygons.setFilters(QgsMapLayerProxyModel.PolygonLayer)

        self.QgsFileWidget3DiResults.fileChanged.connect(self.results_3di_selected)
        self.QgsFileWidgetGridAdmin.fileChanged.connect(self.gridadmin_selected)
        self.QgsFileWidgetSqlite.fileChanged.connect(self.sqlite_selected)

        self.doubleSpinBoxThreshold.valueChanged.connect(self.threshold_changed)
        self.doubleSpinBoxThreshold.setSingleStep(1)
        self.doubleSpinBoxThreshold.setMinimum(0)
        self.doubleSpinBoxThreshold.setValue(DEFAULT_THRESHOLD)

        self.doubleSpinBoxStartTime.valueChanged.connect(self.start_time_changed)
        self.doubleSpinBoxEndTime.valueChanged.connect(self.end_time_changed)

        self.checkBoxUpstream.stateChanged.connect(self.checkbox_upstream_state_changed)
        self.checkBoxDownstream.stateChanged.connect(self.checkbox_downstream_state_changed)

        self.pushButtonClickOnCanvas.clicked.connect(self.pushbutton_click_on_canvas_clicked)
        self.pushButtonCatchmentForSelectedNodes.clicked.connect(self.pushbutton_catchment_for_selected_nodes_clicked)
        self.pushButtonCatchmentForPolygons.clicked.connect(self.pushbutton_catchment_for_polygons_clicked)

        self.checkBoxBrowseResultSets.stateChanged.connect(self.checkbox_browse_result_sets_state_changed)
        self.spinBoxBrowseResultSets.valueChanged.connect(self.spinbox_browse_result_sets_value_changed)
        self.pushButtonClearResults.clicked.connect(self.pushbutton_clear_results_clicked)

    def closeEvent(self, event):
        self.gq = None
        self.unset_map_tool()
        self.closingPlugin.emit()
        event.accept()

    def update_gr(self):
        results_3di = self.QgsFileWidget3DiResults.filePath()
        gridadmin = self.QgsFileWidgetGridAdmin.filePath()
        if os.path.isfile(results_3di) and os.path.isfile(gridadmin):
            self.gq.gr = GridH5ResultAdmin(gridadmin, results_3di)
            output_timestep_best_guess = int(self.gq.gr.nodes.timestamps[-1] / (len(self.gq.gr.nodes.timestamps) - 1))
            start_time = 0
            end_time = int(self.gq.gr.nodes.timestamps[-1])

            self.doubleSpinBoxStartTime.setMaximum(end_time)
            self.doubleSpinBoxStartTime.setSingleStep(output_timestep_best_guess)
            self.doubleSpinBoxStartTime.setValue(start_time)
            print(f'set start_time to {start_time} value from update_gr')

            self.doubleSpinBoxEndTime.setMaximum(end_time)
            self.doubleSpinBoxEndTime.setSingleStep(output_timestep_best_guess)
            self.doubleSpinBoxEndTime.setValue(end_time)

    def results_3di_selected(self):
        results_3di = self.QgsFileWidget3DiResults.filePath()
        if os.path.isfile(results_3di):
            results_3di_dir = os.path.dirname(results_3di)
            gridadmin = os.path.join(results_3di_dir, 'gridadmin.h5')
            if os.path.isfile(gridadmin):
                self.QgsFileWidgetGridAdmin.setFilePath(gridadmin)
                # now update_gr will be fired because gridadmin valueChanged() signal will be emitted

    def gridadmin_selected(self):
        self.update_gr()

    def sqlite_selected(self):
        self.gq.sqlite = self.QgsFileWidgetSqlite.filePath()

    def threshold_changed(self):
        self.gq.threshold = self.doubleSpinBoxThreshold.value()

    def start_time_changed(self):
        self.gq.start_time = self.doubleSpinBoxStartTime.value()
        print(f'set gq.start_time to {self.doubleSpinBoxStartTime.value()} from start_time_changed()')

    def end_time_changed(self):
        self.gq.end_time = self.doubleSpinBoxEndTime.value()

    def unset_map_tool(self):
        try:
            if self.catchment_map_tool is not None:
                self.iface.mapCanvas().unsetMapTool(self.catchment_map_tool)
        except AttributeError:
            pass

    def pushbutton_click_on_canvas_clicked(self):
        if self.pushButtonClickOnCanvas.isChecked() \
                and self.gq.graph_3di.isready:
            self.catchment_map_tool = CatchmentMapTool(
                gq=self.gq,
                upstream=self.checkBoxUpstream.isChecked(),
                downstream=self.checkBoxDownstream.isChecked(),
                parent_button=self.pushButtonClickOnCanvas
            )
            self.iface.mapCanvas().setMapTool(self.catchment_map_tool)
        else:
            self.unset_map_tool()

    def pushbutton_catchment_for_selected_nodes_clicked(self):
        selected_node_ids = []
        for feature in self.gq.target_node_layer.getSelectedFeatures():
            selected_node_ids.append(feature.id())

        if self.gq.graph_3di.isready:
            result_set = self.gq.new_result_set_id()
            if self.checkBoxUpstream.isChecked():
                self.gq.find_cells(selected_node_ids, True, result_set=result_set)
                self.gq.find_flowlines(target_node_ids=selected_node_ids, upstream=True, result_set=result_set)
                self.gq.find_impervious_surfaces(
                    node_ids=list(self.gq.graph_3di.upstream_nodes(target_node_ids=selected_node_ids)))
            if self.checkBoxDownstream.isChecked():
                self.gq.find_cells(selected_node_ids, False, result_set=result_set)
                self.gq.find_flowlines(target_node_ids=selected_node_ids, upstream=False, result_set=result_set)
            self.gq.dissolve_cells()
            self.gq.smooth_catchment_layer()

    def pushbutton_catchment_for_polygons_clicked(self):
        if self.gq.graph_3di.isready:
            polygon_lyr = self.mMapLayerComboBoxTargetPolygons.currentLayer()
            if self.checkBoxSelectedPolygonsOnly.isChecked():
                polygon_features = polygon_lyr.getSelectedFeatures()
            else:
                polygon_features = polygon_lyr.getFeatures()
            for feat in polygon_features:
                target_node_ids = []
                geom = feat.geometry()
                req = QgsFeatureRequest(geom.boundingBox())  # for performance
                for point in self.gq.target_node_layer.getFeatures(req):
                    if geom.contains(point.geometry()):
                        target_node_ids.append(point.id())
                result_set = self.gq.new_result_set_id()
                if self.checkBoxUpstream.isChecked():
                    self.gq.find_cells(target_node_ids, True, result_set=result_set)
                    self.gq.find_flowlines(target_node_ids=target_node_ids, upstream=True, result_set=result_set)
                    self.gq.find_impervious_surfaces(
                        node_ids=list(self.gq.graph_3di.upstream_nodes(target_node_ids=target_node_ids)))
                if self.checkBoxDownstream.isChecked():
                    self.gq.find_cells(target_node_ids, False, result_set=result_set)
                    self.gq.find_flowlines(target_node_ids=target_node_ids, upstream=False, result_set=result_set)
            self.gq.dissolve_cells()
            self.gq.smooth_catchment_layer()

    def pushbutton_clear_results_clicked(self):
        self.gq.clear_result_cell_layer()
        self.gq.clear_result_flowline_layer()
        self.gq.clear_catchment_layer()
        utils.iface.mapCanvas().refreshAllLayers()

    def checkbox_upstream_state_changed(self):
        try:
            if self.catchment_map_tool is not None:
                self.catchment_map_tool.upstream = self.checkBoxUpstream.isChecked()
        except AttributeError:
            pass

    def checkbox_downstream_state_changed(self):
        try:
            if self.catchment_map_tool is not None:
                self.catchment_map_tool.downstream = self.checkBoxDownstream.isChecked()
        except AttributeError:
            pass

    def checkbox_browse_result_sets_state_changed(self):
        self.spinBoxBrowseResultSets.setEnabled(self.checkBoxBrowseResultSets.isChecked())
        if self.checkBoxBrowseResultSets.isChecked():
            self.gq.filter = [self.spinBoxBrowseResultSets.value()]
        else:
            self.gq.filter = None
        self.iface.mapCanvas().refreshAllLayers()

    def spinbox_browse_result_sets_value_changed(self):
        print('spinbox_browse_result_sets_value_changed called')
        if self.checkBoxBrowseResultSets.isChecked():
            self.gq.filter = [self.spinBoxBrowseResultSets.value()]
            print(f'spinbox_browse_result_sets_value_changed(): filter set to {[self.spinBoxBrowseResultSets.value()]}')
            print(f'spinbox_browse_result_sets_value_changed(): filter is now {self.gq.filter}')
            self.iface.mapCanvas().refreshAllLayers()

    def result_sets_count_changed(self):
        print('result_sets_count_changed called')
        if len(self.gq.result_sets) > 0:
            self.checkBoxBrowseResultSets.setEnabled(True)
            self.spinBoxBrowseResultSets.setMinimum(min(self.gq.result_sets))
            self.spinBoxBrowseResultSets.setMaximum(max(self.gq.result_sets))
            self.spinBoxBrowseResultSets.setValue(max(self.gq.result_sets))
            self.spinbox_browse_result_sets_value_changed()
        else:
            self.checkBoxBrowseResultSets.setEnabled(False)


def nearest_value(layer: QgsVectorLayer, fieldname: str, value: int, up: bool):
    # TODO handle empty layer
    # TODO handle requests for non-existent or non-int fields
    if layer.featureCount() == 0:
        return None
    idx = layer.fields().indexFromName(fieldname)
    minval = layer.minimumValue(idx)
    maxval = layer.maximumValue(idx)
    if value < minval:
        return minval
    if value > maxval:
        return maxval
    request = QgsFeatureRequest()
    clause = QgsFeatureRequest.OrderByClause(fieldname, ascending=up)
    orderby = QgsFeatureRequest.OrderBy([clause])
    request.setOrderBy(orderby)
    features = layer.getFeatures(request)
    for feat in features:
        found_val = feat.attributes()[idx]
        if up:
            if found_val >= value:
                return found_val
        else:
            if found_val <= value:
                return found_val
    return None
